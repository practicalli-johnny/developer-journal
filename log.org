# 100 Days Of Code - Log



* 20081015 - Day 31:
** Thoughts for today
   More work on the ClojureBridge install guides (as I am on a roll).

** Code from today
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/386f9f2219cb0207fb2eb14b7ebf6863f8941ed6][Updated atom protoREPL and Proton install guides]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/a1f1f72a3620b36ffd265d77b68e17e6eac736b4][Updated VSCode and Calva section - section comments]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/af974ca883abc07e9633381161862f4043da3b2b][Update: Java install - openjdk guides by OS]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/671943ddde65932a1b8e8e3e74a698b8523ba6a0][Update: Leiningen install guide]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/a724a9a62143d3f4643985b0b587a83b10887a40][Updated: Install guides and Editor overviews]]


** Activities in detail
   Lots of changes to the [[https://clojurebridgelondon.github.io/workshop/development-environment/][development environment section of the ClojureBridge London workshop]].

*** Updated atom protoREPL and Proton install guides
    Changed files to consistent naming convention

*** Updated VSCode and Calva section - section comments
    Added comments to each section to make changes easier to do by specifically highlighting each operating system section.

*** Update: Java install - openjdk guides by OS
   Updated the installation instructions to use OpenJDK 8 where possible.

   Used simpletabs plugin to create a separate tab for each operating system.

*** Update: Leiningen install guide
    Added operating system sections via simpletabs plugin

    Added more install options, including GitBash for windows

    Moved the checking of the install to the bottom of the page

*** Updated: Install guides and Editor overviews
    Changed the install guide list into a table for each of the common tools (Java, Leiningen, Git).

    Added brief overview of each editor to start students thinking about which editor they may want to use.


* 20081014 - Day 30: Spacemacs Clojure layer hacking continued
** Thoughts for today
   A wet day is a good day to focus when working at home.

   Started a new coaching relationship today with an experienced Python developer.  Had a great first catchup over hangouts and defined some tasks to work on.

   Testing a pull request to make the REPL and REPL history buffers a better experience - still some work required.

** Code from today
*** Testing [[https://github.com/syl20bnr/spacemacs/pull/11431][#11431 pull request]]

** Activities in detail
*** Testing a pull request from Magit
    Trying out a pull request as a branch is really easy to do thanks to Magit.

    Open a file from the Spacemacs repository, eg ~.emacs.d/README.org~.

    Open Magit status, ~SPC g s~

    ~b~ opens the branch menu
    ~y~ opens a branch from a pull request, prompting you for the URL.

    And that is it.  As this commit contains elisp changes, then I can go and evaluate the code in a buffer, or restart Spacemacs to pick up the changes. I should create a screen cast for this.

*** Hacking the Spacemacs Clojure layer
  Some more hacking around with a pull request for the Spacemacs Clojure layer, improving the Vim Experience for the Clojure REPL and REPL history buffers.  Both these buffers are configured only for Vim Insert or Emacs states, not usable in Vim normal state.  This is unfortunate at both these buffers open in Vim normal state, so you have to change state before doing anything

Trying out [[https://github.com/syl20bnr/spacemacs/pull/11431][#11431 pull request]] I noticed that ~RET~ is not working in the REPL buffer.  Including ~n~ and ~p~ navigation in the pull request is really needed in the REPL History buffer, to navigate between expressions, along with replicating the existing [[https://cider.readthedocs.io/en/latest/using_the_repl/#key-bindings][vim insert keybindings]].

I opened a Clojure source file and started the REPL.  I opened the REPL buffer with ~, s s~.  Whilst still in Vim normal mode I used ~, P~ to open a buffer with the REPL history.  That all works very well.

I cant jump to each expression (as you can with ~n~ and ~p~ in vim insert mode).  However, I can press ~RET~ to send the current expression to the REPL buffer and close the REPL history.

With the cursor back in the REPL buffer in Vim normal mode, ~RET~ doesnt make the expression evaluate in the REPL buffer, it does nothing.  If I switch to Vim insert, ~i~, then of course I can evaluate the expression.  I've tried a few examples and it seems something is missing.

*** Multi-line editing in the REPL
    I found an example of multi-line editing in the REPL in the #emacs channel, so considering a pull request that does the equivalent of this, but defined in the usual keybinding form in the Clojure layer.  ~RET~ creates new lines and indents, ~C-RET~ evaluates the expression.  This works the same way in other tools, eg. Atom, VSCode, LightTable, rebelreadline, etc

#+BEGIN_SRC elisp
  (define-key cider-repl-mode-map (kbd "RET") #'cider-repl-newline-and-indent)
  (define-key cider-repl-mode-map (kbd "C-<return>") #'cider-repl-return)~~~
#+END_SRC

Perhaps a ~:variable~ can be added to the Clojure layer to allow configuration of a single or multi-line REPL buffer.


* 20081013 - Day 29: Hacking Spacemacs REPL and History
** Thoughts for today

   I havent used the REPL history buffer feature much in Spacemacs and today I remembered why.  It works great for Emacs state, but doesnt work well for Evil as you have to switch from Vim normal to Vim insert states to do anything.

   Luckily someone has started working on a pull request to address this.

   I realised the book was a bit out of date regarding the REPL history and history buffer, so gave it a quick update.

** Code from today
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/69ae2445c3c0911b5f5b75818db8b35d41830462][Update - Clojure history and cider-repl-history]]

** Activities in detail
*** Update - Clojure history and cider-repl-history
    Added table of keybindings for scrolling backwards and forwards through the REPL buffer history to my personal config, ~.spacemacs~.

    Changed keybinding documentation to use unicode arrow keys. Added specific keybindings and commands for working with the cider-repl-history popup buffer.

*** Hacking the Spacemacs Clojure layer
    A new pull request for the Spacemacs Clojure layer was added today, [[https://github.com/syl20bnr/spacemacs/pull/11431][#11431 Clojure enhancements]]

1. add a keybinding to open the cider repl history buffer in an evil way
2. evilfy ~cider-repl-history-mode-map~
3. allow to send input to a cider repl in normal mode with ~RET~


    To summarise the pull reqest, ~, P~ in Vim normal mode in the repl buffer leader would open the repl-history buffer.  ~RET~ would send the current expression under the cursor to the REPL and close the REPL history buffer.  ~RET~ in the REPL buffer in Vim Normal mode would evaluate the current expression (without having to go into vim insert state).

    Having experimented with the repl-history it is definitely confusing to have to switch to vim insert mode to call the buffer history and again switch to vim insert. I would like to have ~SPC s h~ keybinding that opens a buffer with repl history in vim normal mode, which i can navigate quickly between each expression in that history and press ~RET~ to push that expression back into the REPL buffer for bonus points you could evaluate the expression just pushed without having to go into vim insert mode.

    It would be nice to have different keybindings, one that quits the history after you send the expression (so this is what ~SPC~ or ~RET~ currently does in vim insert mode), the other vim insert keybindnigs keep the repl history open.

    ~RET~ is for vim normal mode, so you can evaluate an expression in the repl buffer without having to go into vim normal mode.

    My own preference for a REPL history keybinding would be ~, s h~ for ~major-mode > cider > history~.  I am not sure how ~P~ means history in a mnemonic way, unless it is for Previous?  If P is used in cider itself, then I am okay with that. For a top level keybinding for REPL history a meaningful symbol could be used, as is used to start the repl.  So you could have ~, s h~ and ~, <~ which both call the repl-history

    ~, s h~ avoids switching to the repl buffer first to get to the history and especially if somebody would want to eval form again

    In cider it is ~C-c M-p~, but this does not fit the mnemonic menu system. ~, s h~ and ~, <~ fits into the existing Spacemacs keybindings and mnemonic menu approach.  I would be interested to hear from others as to what they prefer.


Spacemacs Clojure layer related issues:
https://github.com/syl20bnr/spacemacs/issues/4124
#4124 Support Emacs lisp keybindings in Clojure mode
Emacs lisp has some useful keybindings like "go to end of line and evaluate last sexp" that are absent from the Clojure mode keybindings.
Clojure, Enhancement :relaxed:, Key Bindings

* 20081012 - Day 28: More ClojureBridge London dev tools
** Thoughts for today
   If I didnt use Spacemacs, what editor would I use.  I havent found a more suitable environment for myself yet, but as I document tools for ClojureBridge London, then hopefully I will have a better view.

** Code from today
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/5cda41640d4357014f604829e382662633440e5b][Update: Summary Navigation - Friday section]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/2019c4860810a794cf99c32c27bb33eb090a5910][New: VSCode and Calva extension install guide]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/fb17de0300dcfa06c69b116d8874937af6305c0b][Configure ProtoREPL with Leiningen]]

** Activities in detail
*** Clojure development tools options

    I am still trying to decide which tools I like for Clojure development, other than Spacemacs of course.

    Atom.io and ProtoREPL are pretty polished, however, the keybindings for ProtoREPL are more complicated than Emacs. Using Proto-mode with ProtoREPL gives more sensible keybindings as it gives a Vim multi-modal editing experience and a Spacemacs style menu.  The Proton menu seems to have the basics, but there are some things that could be added (que a pull request, as proton is written in ClojureScript after all).

    VisualStudio Code is a pretty slick editor and Calva is the best of several extensions to support Clojure development.  I just find VSCode a little tricky to use as I havent read the user guide properly I guess.  I would prefer if Calva started a REPL from within VSCode, rather than starting one outside and connect, although it works well.  There are Vim extensions for Code too.

    I should be able to get a better handle on ProtoREPL and Calva as I put together a simple user guide for ClojureBridge London workshop.

*** ClojureBridge London workshop updates

    Added a distinct Friday section to make it easier to see that the workshop has content for both Friday evening and Saturday.

    Created a new install guide for VSCode and Calva extension, using new tabbed format to separate the Operating System specific information.

    Updated the ProtoREPL install guide with details on how to configure with Leiningen, which is an important step in the ProtoREPL setup.

* 20081011 - Day 27: ClojureBridge London dev tools setup
** Thoughts for today
   I found a nice plugin for Gitbook to have a tabbed section in a page, improving the presentation of a single install page for each of the tools.  Any differences in approach, e.g. installing on a particular operating system, can be put in their own tab. It probably shows my bias that I put Ubuntu Linux as the default tab (oops).

   Had a catchup with a company interested in getting involved more in the London Clojurians community.  We discussed the ClojureBridge London event and other activities that the community does.  Now have two ClojureBridge London events in planning for 2019.

   Assisting a couple of speakers with their talk titles and descriptions for the ClojureX conference this year.  Almost everyone is published on the schedule now.

   I will be coaching a new person this weekend, just arranging the details and starting to set expectations.

** Code from today
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/a8a861f1bd216613726badf790ceb6f83d1e1fc7][Add Gitbook Plugin - simple tabs]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/b29e3f5e7c5a0e2b052ba7b32e211d2d80dd464e][Update Atom ProtoREPL and Proton development tools]]

** Activities in detail
*** Update Atom ProtoREPL and Proton development tools
    Updated to use the simple tabs plugin to provide a simple way to separate the
unique install steps for each operating system.

    Added installation instructions for all operating systems.

    Added details on how to run and test the installation.
*** Add Gitbook Plugin - simple tabs
    A plugin for adding tabbed sections in a page, useful for separating out
specific details in a wider article.

    This plugin will be used for the development environment section.

* 20081010 - Day 26: Spacemacs and ClojureBridge dev tools
** Thoughts for today
It is great to hear from people reading your books, blogs, etc.  I received some very warm feedback today from a developer who is interested in learning Clojure and is really enjoying my practicalli books.  This is great to hear and really helps motivate me to finish those books.

** Code from today
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/159fcc6c2bcec1f918d463dcc3bba93d0451adfe][Spacemacs book - Updated debugging section]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/eeac717165ef5426b4c3784915e98daa1d59f3fa][Spacemacs book - Converted transient state menus list to a table]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/3854cc06f6ae31b49876c1db0b831abfc6d3502d][Spacemacs book - Refined page on enhanced clojure experience]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/8f68f1b579178543db63a64b4ce284260d000ea9][Spacemacs book - Added section on opening Magic Full Screen]]
*** [[https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commit/488004871a2a6c581effee302c4985b5e9a2a596][ClojureBridge London - Starting rework of development environment section]]

** Activities in detail
   Continued working on the Spacemacs book, organising the debugging section a little better.  Added details of how to run Magit in full frame, which I find much easier to work with changes.

   Also worked on the development tools install guides for ClojureBridge London.  Although we have Klipse REPL built into the workshop material, it doesnt save any work.  Obviously Klipse is also not going to be the follow on editor that the students use, so we use the Friday evening of the event installing a Clojure aware editor.  The editor tends to be one of Atom.io, VisualStudio Code, Emacs (yes, we have had several students using Emacs, mostly with a Spacemacs setup).  Some students that are studying Java are using Intellij, so we also help with installing Cursive.

* 20081009 - Day 25: Quarter of the way there
** Thoughts for today
   Added quick reference section for adding unicode characters

   Mainly using unicode characters in the content of my books/guides to represent keyboard characters, such as arrow keys.  It is assumed that these unicode characters make the keybindings easier to understand.

** Code from today
*** [[https://github.com/practicalli/atom-protorepl-content/commit/eac9a377d238c4a33437930fa098eeaa72a7ca69][New gitbook on using Atom and protorepl with Clojure]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/1a0f2b166d97f232ea08404d09b531dc50196dcd][Embedded video - Magit create local repo and add remote]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/3dbf246f89113b9c62b00a4b82ada3c05dbb7f39][Added quick reference section for adding unicode characters]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/686916d4864df096a48eda8a9d89d1185f0fd266][Updated Magit section]]

** Activities in detail
*** Spacemacs book updates
    I started on using Atom and ProtoREPL for Clojure development when I was coaching a developer who wanted to learn some Clojure. Although I had published the content a while ago, I realised I had not pushed the content to github.

    I used this as an opportunity to create a video of using Magit in Spacemacs.  The video covered how to create a new local Git repository, create the first commit, add a remote repository and push the commit to the remote. This should be exactly the same for GitLab.

    https://www.youtube.com/watch?v=AdEOazt1rD0

    I embedded the video in the section on [[https://practicalli.github.io/spacemacs/magit/create-local-repository.html][creating a local Git repository]]

    I also took the opportunity to add the very cool Git Timemachine, which provides an easy way to navigate the code commits for a particular file and see the file contents change as you visit each commit.  The Git Timemachine is very useful for reviewing how a file has evolved.  Its also useful for ~live coding~ demos where you dont want to show how a project has evolved, but dont want to waste time doing all the typing.

    https://practicalli.github.io/spacemacs/magit/timemachine.html

* 20081008 - Day 24: Events, events, events
** Thoughts for today

   Community events are fun and quite a responsibility too.  Today we reviewed the speaker schedule for ClojureX, aiming to make the best flow of the talks and ensure we give the best possible experience for the audience and the speakers.  Also organising a workshop before the ClojureX conference at uSwitch.  We also have a hack day on 15th December along with the Scala community.

   The evening was the Clojure dojo at uSwtich were we...

** Code from today
*** [[https://github.com/practicalli/practicalli.github.io/commit/0521a3d74ea08b244c8d1613febc809727ff3d2f][Updated the links to my books to use https]]
*** [[https://github.com/practicalli/practicalli.github.io/commit/c6d643623476ba2f4274dc990ddfe0cc7781c4d7][Added ClojureBridge London workshop to list of my online books]]
** Activities in detail
*** Updating Practicalli website
    Added the ClojureBridge London workshop as a link on my Practicalli website.  The workshop is complete, unlike most of my other books, so good to show (myself at least) that I can finish one.  Will focus more on finishing the Spacemacs book and reworking the Clojure Practicalli book.

Updated all the links to my books to use https rather than http, as this makes Google and other search engines happier.
*** Clojure dojo - Native Clojure binaries with GraalVM
    I paired with a friend who is starting to learn Clojure and we used [[https://www.graalvm.org/][GraalVM]] to create a native binary from a Clojure application.

    While I set them up with Clojure via ~brew install clojure~ and installing [[https://leiningen.org][Leiningen]], I installed  [[https://www.graalvm.org/][GraalVM]]

    GraalVM is just a tarball (Linux, Macosx) that is extracted and the bin directory added to the executable path.  It turns out later that I also needed to install ~zlib~ to create the native image from my Uberjar file.  I assume the Uberjar file used zlib compression, or perhaps the zlib library is used to compress the native binary in some way.  Either way, it was just a matter of ~sudo apt install zlib-dev~.

    Development of the Clojure app wasnt any different from normal.  We did use the Leiningen ~app~ template to add code and configuration to allow our Clojure application run from the command line, via ~java -jar target/uberjar/my-app-standalone.jar~

    Once the code was written the application was packages using ~lein uberjar~.

    By installing GraalVM and putting it up front in the executable path, the GraalVM version of Java is run when running ~java -version~.  To check Clojure the application still works on GraalVM we just needed to run it via the command line.

    GraalVM has a command to create a native binary

* 20081007 - Day 23: Spacemacs Sunday
** Thoughts for today
   Discussing approaches for setting environment variables for Clojure applications.  Its quite common to use environment variables for key settings, like the port of your web application using, although using a map for your configuration is more prevalent when there are lots of environment variables to set.

   Using keyboard symbols for certain keys can make documentation easier to follow, e.g. for arrow keys.  I could use some CSS with the ~<kbd>~ tag, although adding html tags makes markdown less clean.  Using unicode characters works really well though and of course Spacemacs makes it easy for you to add these characters by name using ~SPC i u~.

   Using org-mode continues to be much more fun that markdown for writing this journal.  I updated the orgmode section with useful stuff I found.  I also just discovered adding (and editing existing) links using ~, i l~.  I also looked at the insert orgmode keybinding, but it generates quite a lot of text and I suspect its something that needs to be exported to work with github

   ~@@html:<kbd>@@ <right> @@html:</kbd>@@~

** Code from today
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/727a25f62dc3519b14f1c35b5ece09cb57cbedd1][Org-mode section major update]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/5a98cbb9cdf1c65115356b8a1d13c4a525681285][Sayid debugger package and clj-refactor are no longer loaded by default]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/34865614e9ff24a02040df3994bc6340b8eba05c][Overview of projectile for working with files only from the current project]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/5106f525d860ed86f849c57aaf9b1324ac257eeb][New section - Linting]]

** Activities in detail
*** Environment variables
    Separate environment variable definitions are used when you have a small number of settings, e.g. for PORT, often using the https://github.com/weavejester/environ library.

    Using maps is also a good approach, especially where there are a great number of settings for different environments.  The https://github.com/juxt/aero library is a nice clean way to specify a collection of environment settings across multiple environments.

    In my last project, we deployed in dev, qa, uat and prod environments with multiple services (oracle, tibco, datomic, etc) and used aero to great effect.

*** Spacemacs - sayid and clj-refactor optional
    Sayid debugger package and clj-refactor are no longer loaded by default.

    Sayid has caused a few issues with Cider recently so it is left to the user to decide if it is useful for them.

    clj-refactor has not been updated in several years and some of its functionality is moving into clojure-mode.

    Both these packages can be included by defining their package names as :variables on the clojure layer

*** Spacemacs - using projectile to manage project files and buffers effectively
    Overview of projectile for working with files only from the current project, making it easier to open files and navigate buffers for a project.

    Using helm transient state to help tidy up buffers.

    Used ~SPC i u~ to add unicode characters for arrow keys, e.g.ðŸ¡„ðŸ¡‡ðŸ¡…ðŸ¡†

*** Spacemacs - Linting
    Added a new section on Linting tools, providing a quick overview of linting tools I use for my Clojure projects, Joker and Eastwood.

    Joker is simpler to use, thanks to the clojure-lint layer.  It does use an external binary, which I placed on my existing executable path.  Joker uses a
sub-set of Clojure so it may give a few inaccuracies, these are usually false positives on things like macros.  There is a way to tell joker to ignore certain symbols though.

    Still a bit of work to do on these sections, but they cover the basics.

* 20081006 - Day 22: Coaching a developer new to Clojure
** Thoughts for today
   Had a quick look at the many Clojure extensions for VisualStudio Code.  [Calva](https://marketplace.visualstudio.com/items?itemName=cospaia.clojure4vscode)
seems the most maintained.  It requires you to start a repl outside of the editior, which I am not that keen on as it means more complexity.  However, it seems to generally be the better choice.

** Code from today
*** Nothing in Github, but example code in activities section of this journal
** Activities in detail
A developer considering Clojure reached out to me with the following question.

---
I have these two types of class definitions in Java:

    public class SomeClass {
        public void generateFor(SomeArgType argument);
    }
              ----- or ----

    public class SomeClass {
        public SomeType generateFor(SomeArgType argument);
    }

How do you write them in Clojure if you even write any such definitions to start with. I know you dont have types or interfaces or classes as such.
---

It was an interesting reminder of where I had come from several years ago.  OO languages and especially Java have become the main-stay of much application development because its a very stable language (Java) with a highly optomised runtime environment (JVM).  My journey into Clojure has allowed me to use a much simpler syntax with barely any boilerplate code.  I find it quite challenging to go back to the Java and OO way of thinking.

So, I tried to answer the question with as meaningful an answer as possible, so I just wrote some code and explained how it worked.

---
Here is a simple function which would typically be defined in a namespace (a package in Java).

This function just generates a message, so nothing very exciting in this code.  First we define a function, as you would define a method, but we dont need to do it in a class.  The function takes one argument and returns what ever is the result of the last expression (no need to define an explicit result call.

The If function determines which is the last expression to be called.  If the condition, (= feature "function") - compare the value of feature with the string "function", is true then use the first line after the condition, if false then use the second line.  If is a macro, so acts slightly different to normal function evaluation.

#+BEGIN_SRC clojure
(defn feature-generator
  "I am a very simple function, this is my docstring
  Usually I would tell you something useful about myself"
  [feature]
  (if (= feature "function")
    (str "In Clojure everything is a" " " feature)
    (str "Clojure doesnt use:" " " feature)))
#+END_SRC

Now we have the function defined, with a name that we can call it by, we can call it anywhere in our namespace (or in another namespace if we add it to that namespace).

Here is the function call, followed by the result as a comment underneath


#+BEGIN_SRC clojure
(feature-generator "objects")
;; => "Clojure doesnt use: objects"
#+END_SRC

Lets call it again with a different argument

#+BEGIN_SRC clojure
(feature-generator "classes")
;; => "Clojure doesnt use: classes"
#+END_SRC

And we can use the function call inside another function call... this is how we build up our application.

Here we call the str function that joins two things together to make a string.  The first argument to str is the result of a function call, so the Clojure runtime (the REPL) first goes and evaluates that function which is then passed to the str function along with the string as a second argument

#+BEGIN_SRC clojure
(str
 (feature-generator "function")
 ", with persistent data structures, eg maps, vectors")
;; => "In Clojure everything is a function, with persistent data structures, eg maps, vectors"
#+END_SRC

This is a very quick example of defining your own behaviour in Clojure and calling it.

The other important aspect of Clojure is to model data, for which we use either lists (linked list), vectors (an array), maps (hash map), sets (unique values).  We dont need generics here and we dont need to define types of our data (although we can define a specification, usually if we are pulling data from outside of Clojure).

If we were going to model different science fiction worlds, we could construct a data structure as follows

#+BEGIN_SRC clojure
(def starwars
  {:characters
   {:jedi   ["Luke Skywalker"
             "Obiwan Kenobi"]
    :sith   ["Darth Vader"
             "Darth Sideous"]
    :droids ["C3P0"
             "R2D2"]}
   :ships
   {:rebel-alliance  ["Millenium Falcon"
                      "X-wing figher"]
    :imperial-empire ["Intergalactic Cruser"
                      "Destroyer"
                      "Im just making these up now"]}})
#+END_SRC

We have bound the name starwars to a maps of maps with vectors.

There are lots of functions that help us get or update (creates a new data structure) this data structure

Lets start simple and get a value from the map using a key

#+BEGIN_SRC
(get starwars :characters)
;; => {:jedi ["Luke Skywalker" "Obiwan Kenobi"], :sith ["Darth Vader" "Darth Sideous"], :droids ["C3P0" "R2D2"]}
#+END_SRC

We can see that the result itself is a map, so we could use another get function around the first to drill down further in the map.
Clojure has a function that allows you to traverse the path in the map though.

#+BEGIN_SRC clojure
(get-in starwars [:characters :jedi])
;; => ["Luke Skywalker" "Obiwan Kenobi"]
#+END_SRC

The developer was appreciative of the detailed answer, however, as this was all over email its hard to know how well they understood the examples.  I will suggest some resources they can use to learn.

* 20181005 - Day 21: Hacking markdown into org-mode
** Thoughts for today
   Spacemacs org-mode is a much richer experience when it comes to writing when compared to markdown in Emacs.  Thanks to Bobby Towers for reminding me that I should be using org-mode to write this journal.  Being able to fold up headings in org-mode, add code blocks that evaluate and move sections around easily are well worth the conversion of this file from markdown.

** Code from today
*** Convert log content to org-mode format
*** [[https://github.com/jr0cket/100-days-of-clojure-code/commit/4120ff9ec1ee02a9f87da10927848beb8043a0eb][Move the Log.md to log.org and converted to org-mode]]
** Activities in detail
*** Rename log.md to log.md
    This was a simple case of opening Magit ~SPC g s~ and renaming the file using the ~!~ keybinding to bring up a prompt that runs any git command you type.  There is no specific rename file option in Magit (that I am aware of), so this is a convenient way to run those odd git commands.
*** Convert markdown content to org-mode
    Converting from markdown to org-mode is fairly simple, especially with all the Vim editing tricks I have learnt over the last few weeks.

    Source code blocks use the ~#+BEGIN_SRC~ directive, rather than three back-tics in markdown. The advantage with org-mode is that your code is syntax highlighted in the editor and actually executable (via org-mode Bable).  So it is much easier to establish you have working code in your documentation.

    For inline code and shell command references, we can just surround with ~ to highlight as a mono-type font face.

    Hyperlinks are the same way around as they are defined in HTML, the link first and then the anchor text.  Not sure why markdown is the reverse.  The link and anchor text are each surrounded with square brackets, e.g. [http://spacemacs.org] and [Spacemacs], then both are wrapped inside another pair of square brackets to make the link.  Org-mode then renders the text so the anchor is now a hyperlink in your text, only showing the anchor text.

    How well this all works we will discover when I push this big change to Github.

* 20181004 - Day 20: Hacking Spacemacs and code folding
** Thoughts for today
   Spacemacs is infinitely hackable, but learning to use the features it just gives you is much quicker :)

   I love writing my Spacemacs book and its great to see others finding it useful.

** Code from today
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/ec7ec3a250301b4f5a93ceb8d3c8536cd1951d81][Code folding]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/e41f6783f59e9ba711836e2197817a98eb4ccc64][Spacemacs Vim]]
*** [[https://github.com/practicalli/spacemacs-gitbook/commit/16ad893898dddd5d32a1458b655c82c3cedf712b][Font and frame scaling]]

** Activities in detail
*** Spacemacs menus for Vim Normal mode
    I keep finding more ways to do things faster, mostly by accident as I pressed the wrong key.  I have found a few menus on the keys ~# * g z~ that I wanted to investigate and today was the day.

    I use ~g~ for commenting code ~g c c~ and for toggling character case ~v g ~~  or word case ~SPC v g ~~

*** Code folding
    Interesting discussion on how Spacemacs does code folding in the #spacemacs channel of the London Clojurians Slack community. A suggestion was made about folding different levels of code, in a similar manor to org-mode and magit (magit has the stage, file and hunks that can be expanded and collapsed).

    I was not particularly convinced that changes were needed at first.  After experimenting I did think that the collapsing of function definitions could be made better for me.  Currently the argument list is collapsed on a function and it would be really useful to keep that shown, along with the ~def function-name~.  If there was a docstring (and there really should be) then that sting would be collapsed too, or just show the first line.

    The default code folding uses some Vim magic and I didnt see an easy way to configure the behaviour.  It is easy to change code folding to a package called [origami](https://github.com/gregsexton/origami.el#does-it-support-my-favourite-major-mode) which enables you to write your own parser in order to create custom folding for your language.

    There is also [evil-vimish-fold](https://github.com/mrkkrp/vimish-fold/blob/master/vimish-fold.el) which some have commented to be really good for every language, however, I dont think this has been added to Spacemacs as a layer yet.  I am trying out Origami now, but it seem less useful for Clojure than evil-fold, as folding seems to only work at the top level.  I could be doing something wrong, or the Clojure parser for origami needs tweeking.  I would love to see the argument list still shown when folding, as an example.

    To try the evil-vimish-fold package without a layer, you can add it to your ~.spacemacs~ file as follows
    1) add the package name ~evil-vimish-fold~ to ~dotspacemacs-additional-packages~
    2) add ~(evil-vimish-fold-mode 1)~ to ~user-config~


------------------------------------------

* 20181003 - Day 19:
** Thoughts for today


** Code from today

*** code

** Activities in detail

* 20181002 - Day 18:
** Thoughts for today

Starting to change the HackTheTower website into HackTogetherLDN.

Supporting new speakers at the New Speaker night organised by the London Java Community.

** Code from today

*** HackTogetherLDN updates
  https://github.com/HackTogetherLDN/hacktogetherldn.github.io/commit/3a5fc3f4bf2ca33a704f231a6759eed08a0c4e6b

** Activities in detail

* 20181001 - Day 17:
** Thoughts for today

Oh my, its October already!

Hacking on my [Practicalli Spacemacs](https://practicalli.github.io/spacemacs) book.  Emacs is a continual joy when it comes to optimsing the process of capturing all the wonderful thoughts my brain has.

** Code from today

*** ,,,

** Activities in detail

* 20180930 - Day 16: Updating ClojureBridge London content
** Thoughts for today
   Adding more content and exercises based on the feedback from the ClojureBridge London event.

** Code from today
   A server side web app that tells you the distance between two cities

** Activities in detail
   Taking some of the feedback we received from the workshop, I updated some of the examples and exercises in the [ClojureBridge London workshop](https://clojurebridgelondon.github.io/workshop/) and started a guide for the larger example of building a website to show the distance between two cities.

*** Small exercises and examples

*** Distance between two cities web app

    With the project created, we started the server with ~lein ring server~ to check it all worked.  To start building the page we added the [hiccup]() library, allowing us write an html web page using just Clojure code.  The ~hiccup.page/html~ function creates a web page and we define a ~[:head ]~ section that contains ~include-css~ and ~include-js~ functions so we can add bootstrap to our website and use some simple styles to make the site look better.

    The data for the countries was defined within a Clojure map, e.g. ~{:city "London" :latitude 51.5074 :longtitude 0.1278}~.  We added a dozen cities as maps to a Clojure vector and bound that vector to the symbol ~locations~.

    To select the cities from the web interface, we added a ~form-to~ function that included two input drop-downs.  Using a ~for~ statement we iterated over the ~locations~ collection and extracted the city name, placing it into the drop down.  This gave us a to and from location to select.

    Using the submit button to call a results page, we extracted the selected cities from the request params.  Then called a function that calculated the distance between two locations using their respective latitude and longtitude positions.

 ------------------------------------------

* 20180929 - Day 15: Coaching ClojureBridge London
** Thoughts for today
   I get a wonderful warm feeling when helping people get into the software industry, especially when its addressing the balance of voices in that industry.  To be able to help those new to development using my favourite language, Clojure, makes it extra special.

   Clojure is quite different from most languages, specifically in the way it encourages you to think about the design of your code.  The simplicity that is achievable with Clojure is something that continues make me smile every day, even after 8 years of learning and working with Clojure.

   The ClojureBridge event had over 20 women enjoying the day.  Six women already had some experience coding and one of them had just found out they had got their first job in the industry.  The rest of the students were very new.  Everyone was very excited about the day and that enthusiasm carried on throughout the day.

** Code from today
*** The student wrote the code today, using examples from my status-monitor app stackoverflow.
** Activities in detail
   I was coaching 4 women who had some coding experience.  Two of them had completed the first 6 levels of the workshop exercise in the afternoon and started building websites using Clojure.

   Each student took a slightly different approch.  One student followed my [Practicalli Clojure WebApps]() step by step guide to building a server side web application with ring and compojure.  The second student used the [leiningen compojure template]() to start building a server side website that calculated the distance between two cities.

   With the project created, we started the server with ~lein ring server~ to check it all worked.  To start building the page we added the [hiccup]() library, allowing us write an html web page using just Clojure code.  The ~hiccup.page/html~ function creates a web page and we define a ~[:head ]~ section that contains ~include-css~ and ~include-js~ functions so we can add bootstrap to our website and use some simple styles to make the site look better.

   The data for the countries was defined within a Clojure map, e.g. ~{:city "London" :latitude 51.5074 :longtitude 0.1278}~.  We added a dozen cities as maps to a Clojure vector and bound that vector to the symbol ~locations~.

   To select the cities from the web interface, we added a ~form-to~ function that included two input drop-downs.  Using a ~for~ statement we iterated over the ~locations~ collection and extracted the city name, placing it into the drop down.  This gave us a to and from location to select.

   Using the submit button to call a results page, we extracted the selected cities from the request params.  Then called a function that calculated the distance between two locations using their respective latitude and longtitude positions.


------------------------------------------

* 20180928 - Day 14: Hacking ClojureBridge London
** Thoughts for today
   Running our 8th ClojureBridge London event to support under represented groups gain experience and build confidence when it comes to codeing.

   Updated some of the ClojureBridge content and examples.

   Some ClojureX conference management.

** Code from today
*** https://github.com/ClojureBridgeLondon/workshop-content-gitbook/commits/master

** Activities in detail


------------------------------------------

* 20180927 - Day 13: Demo-graphics continued
** Thoughts for today
   Some more user research.  Buiding websitest that tell you something isnt as easy as it seams.

   Making good used of Layouts in Spacemacs to organise my work more effectively.

   Continued with building up the SVG library

** Code from today
*** [[https://github.com/jr0cket/webapp-status-monitor/commit/940ec90df0ef87cd69fce7f9e9859c7dfd75488b][SVG elements in Clojure]]

** Activities in detail
   More hacking on the SVG library I have been working on in the status-monitor app.  Continuing to define example SVG elements in Clojure.


------------------------------------------

* 20180926 - Day 12: Demo-graphics
** Thoughts for today
   More experimenting with SVG and included some simple HTML.  At some stage will need to decide what styles to include inline for HTML elements, what to include as templates and what to define as CSS (and any other / additonal css libraries to use).

** Code from today
*** Demos with SVG and HTML
    https://github.com/jr0cket/webapp-status-monitor/commit/93189468fc80938865fb67f4ff6de77f9d4bc724

** Activities in detail
   Hacking with more SVG graphics and wrapping those graphics with HTML.

   Debugging the html output is very easy with the Chrome Inspector.

------------------------------------------

* 20180925 - Day 11: Diversity is a balancing act
** Thoughts for today
   Today was distracted with issues raised around this years ClojureX conference.  Although we strive to get as much balance as possible in the speakers for our annual conference and the last few years have been quite successful, unfortunately we only have a few women speakers confirmed this year.  We spend time reaching out to under represented groups and supporting them in many ways to get involved with the conference.  We do reach out to speakers we want to appear at the conference and this also has a bias to ensure we have a good balance.  Although we have been very successful encouraging new speakers to the conference, the representation of those new speakers has not been as broad this year.  One of our speakers pulled out of the conference as they understandably felt it was not appropriate to speak, especially as they were pair presenting with a colleague who would have contributed to the balance we strive to achieve.  Luckily the speaker had two other colleagues who would bring the same balance that we were hoping for.

   Unfortunately this took up most of the day today and didnt leave much time for coding before heading off to run the Coding dojo at Thoughtworks.  Unfortunately Yolina who has done a wonderful job of running these events for the last few years was ill. I hope Yolina a swift recovery.

   The Clojure code dojo was lots of fun tonight.  We had 3 groups of people fairly new to Clojure, working through lots of 4clojure.com exercises.  We also had a group creating a notification app for the Park Run events.  Unfortunately this popular site does not have a published API, so lots of webscraping with the enlive library was in order.  I spent most of the time coaching the teams through the 4Clojure exercises, helping them to think in a functional way.  We also had a very interesting discussion around functional design patterns and what if any were the relationships between functional and OO patterns.  Our conclusion being that most of the OO patterns provide features that are not available in the language.  Understanding functional design or patterns is more about understanding the Clojure (or Lisp) style of functional programming and what is the so called ~idiomatic~ approach to Clojure.

   I still managed to get some time to work on the Status Monitor, although this was more about defining SVG elements and considering creating a library of SVG components to make it easier to incorporate them in Clojure or ClojureScript projects.

   The day ended on a high note with my pull request to the Compojure Leiningen template merged by @weavejester

** Code from today
*** [[https://github.com/weavejester/compojure-template/pull/25][Compojure template pull request merged]]
*** [[https://github.com/jr0cket/webapp-status-monitor/commit/427c56c5ce5e7c516955d34daa32f49cb3893d79][SVG components namespace with a simple demo]]
** Activities in detail
   Not much coding today, so no real detail to cover.

   Created a new namespace in the status-monitor application for svg-components.  Planning to start converting the [[https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started][Mozilla SVG guide]] and [[https://developer.mozilla.org/en-US/docs/Web/SVG/Element][SVG Elements Reference]].


------------------------------------------

* 20180924 - Day 10: Mocking has never been easier
*** Thoughts for today
    Refined the tests using the ~ring.mock.request~ mocking library that Compojure Leiningen template added when creating the project.

*** Code from today
**** Refactor test to use ring.mock.request
     https://github.com/jr0cket/webapp-status-monitor/commit/a71781610e800f524ce46dfdb0e18653aea19c2d

*** Activities in detail
**** Refining the tests with ring.mock.request

     The test from yesterday was not quite as elegant as it could be.  Although it showed clearly what it was testing, there was much duplication.

#+BEGIN_SRC clojure
 #_(deftest test-monitor-dashboard
   (testing "Test dashboard contains key pieces of information"
     (is (clojure.string/includes?
          (monitor-dashboard {})
          "<title>Area51 Mock Status</title>"))
     (is (clojure.string/includes?
          (monitor-dashboard {})
          "<link href=\"//stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" rel=\"stylesheet\" type=\"text/css\">"))
     (is (clojure.string/includes?
          (monitor-dashboard {}) "<div class=\"jumbotron\"><h1>Mock Status Monitor Dashboard</h1></div>"))
     (is (clojure.string/includes?
          (monitor-dashboard {}) "<h2>Application monitor</h2>"))
     (is (clojure.string/includes?
          (monitor-dashboard {})
          "view-box=\"0 0 100 20\""))))
#+END_SRC

    I refactored the above test to use a let function to create a local binding called response, bound to the value of calling the webapp route ~/dashboard~.  This testing the correct flow of our webapp route and its response.

    The let name ~response~ was bound to the ~/dashboard~ response by calling ~(app (mock/request :get "/dashboard"))~ from the ~ring.mock.request~ mocking library.

    The response is a Clojure map which has a key called ~:body~ that contains the html output for the web page.  So I extract the value using the ~:boot~ key.

    Added ~clojure.string~ to the namespace with an alias ~string~ so I could simply call ~string/includes?~ instead of ~clojure.string/includes?~.  I could refer ~includes?~ into the namespace, however, I prefer to be explicit in the use of libraries (unless there is extensive use of specific functions in a namespace that is focused on the context of those functions, i.e. a UI namespace that uses Hiccup).

    So, the refactored test now looks a little more streamlined.

#+BEGIN_SRC clojure
 (deftest test-monitor-dashboard
   (testing "Test dashboard contains key pieces of information"
     (let [response (app (mock/request :get "/dashboard"))]
       (is (= (:status response) 200))

       (is (string/includes?
           (:body response)
            "<title>Area51 Mock Status</title>"))
       (is (string/includes?
            (:body response)
            "<link href=\"//stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" rel=\"stylesheet\" type=\"text/css\">"))
       (is (string/includes?
            (:body response) "<div class=\"jumbotron\"><h1>Mock Status Monitor Dashboard</h1></div>"))
       (is (string/includes?
            (:body response) "<h2>Application monitor</h2>"))
       (is (string/includes?
            (:body response)
            "view-box=\"0 0 100 20\"")))))
#+END_SRC

 ------------------------------------------

* 20180923 - Day 9: Testing is fun
** Thoughts for today
   More testing today and taking a brief look at the mocking framework that Compojure Leiningen template added to the test code generated.

   Also has a quick look at eftest from @weavejester which is supposed to be faster and can run more tests in parrallel than just running ~lein test~.  I mainly wanted to use it for the coloured output at this stage (as I only have a few tests).

   By accident I found the Emacs transpose keybinding is still in Spacemacs today. Instead of pressing ~M-TAB~ I was pressing ~M-t~ and swapping around the two words either side of the cursor position.  The transpose call even jumps over and ignores comments and other separators.

   The standard Spacemacs bindings for transpose are as follows:

*** ~SPC x t c~	swap (transpose) the current character with the previous one
*** ~SPC x t w~	swap (transpose) the current word with the previous one
*** ~SPC x t l~	swap (transpose) the current line with the previous one

  This is something else to add to my [[https://practicalli.github.io/spacemacs][Spacemacs for Clojure development guide]].

** Code from today
*** Added eftest plugin
    https://github.com/jr0cket/webapp-status-monitor/commit/b5f8b2a83ce9839c7881b4a5b80d8d7911b13fb2

*** Added tests for monitor dashboard
    https://github.com/jr0cket/webapp-status-monitor/commit/d2016c004b9122677986f3933270e900ce59d0a8

*** Added author and documentation to test namespace
    https://github.com/jr0cket/webapp-status-monitor/commit/f5eed17e129ffd2e6c402d1292fb900164129259

*** Experimenting in the REPL
    https://github.com/jr0cket/webapp-status-monitor/commit/bfa92e18ebb5b57c223c6b6851277ee88c1819c7

*** Updated the Readme to include an ascii text logo
    https://github.com/jr0cket/webapp-status-monitor/commit/f8b6bef2486fc972e0f82599b9303c0616ef5195

** Activities in detail
*** Adding an ascii text logo
    Perhaps a little superfluous but an easy thing to add is an ascii text logo of the project name.  I use the [[http://patorjk.com/software/taag/#p=display&f=Fire%20Font-k&t=status%20monitor][text to ascii art generator (TAAG)]] and the Fire Font.

    The output of the generator was copied into a text block in the project ~README.md~ file.

*** REPL experiement - calling monitor-dashboard function

    Confirming the output of the ~monitor-dashboard~ function by calling that function via the REPL, using an empty map {} as the function argument.

    The ~monitor-dashboard~ is currently passive and so does not use any data from the request map.

    If the ~monitor-dashboard~ function did use data from the request map, we would need to mock that in the call to ~monitor-dashboard~.

*** Testing monitor-dashboard
    Using ~clojure.string/includes?~ to see if the result of calling the ~monitor-dashboard~ function includes specific sub-strings.

    This could be done using the mock framework and put into a let to make the code cleaner.

#+BEGIN_SRC clojure
(deftest test-monitor-dashboard
  (testing "Test dashboard contains key pieces of information"
    (is (clojure.string/includes?
         (monitor-dashboard {})
         "<title>Area51 Mock Status</title>"))
    (is (clojure.string/includes?
         (monitor-dashboard {})
         "<link href=\"//stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" rel=\"stylesheet\" type=\"text/css\">"))
    (is (clojure.string/includes?
         (monitor-dashboard {}) "<div class=\"jumbotron\"><h1>Mock Status Monitor Dashboard</h1></div>"))
    (is (clojure.string/includes?
         (monitor-dashboard {}) "<h2>Application monitor</h2>"))
    (is (clojure.string/includes?
         (monitor-dashboard {})
         "view-box=\"0 0 100 20\""))))
#+END_SRC

    Tomorrow I'll refactor the above test to use a ~let~ value for the response from calling monitor-dashboard. I will also use the ~(app (mock/request :get "/"))~ call in the ~let~ and compare the ~:body~ from the response.

*** Added eftest plugin for pretty results report

    [[https://github.com/weavejester/eftest][eftest]] provides a faster testing tool and syntax coloured reporting of results, making it nicer to use that ~lein test~.

    Run the tests using the eftest plugin on the command line using ~lein eftest~

    The plugin uses several dependencies

    [/images/clojure-testing-eftest-dependencies.png][Clojure Leiningen eftest plugin dependencies]

    The output in this test run that contains two test failures is very clear to understand and spot the issues easily.

    [/images/clojure-testing-eftest-test-run-failures.png][Clojure Leiningen eftest plugin - failing test run]


------------------------------------------

* 20180922 - Day 8: Clojure coaching and Testing
** Thoughts for today
   Started coaching a developer today.  It has been a few months since I coached, so am happy to be starting again.  Coaching really does help me exercise my mind and it is very enjoyable to guide someone.

   One decision taken in the coaching was which continuous integration server to use.  I realised I should start writing some tests and set up a CI server for the status monitor project.  The simplest approach for a CI server was to use [CircleCI](https://circleci.com/) that provides CI as a service and hooks up easily to Github projects.  CircleCI is also written in Clojure, so its great to support them.

** Code from today
*** Added tests for components
    https://github.com/jr0cket/webapp-status-monitor/commit/2647704466ea05c3fb6ba3eba46fa28d341000e7

*** Updated the Readme and added CircleCI status badge
    https://github.com/jr0cket/webapp-status-monitor/commit/f7912e1e8151b3c399bd3c4e517d3a7d11709f8e

** Activities in detail
*** Setting up CircleCI for the status-monitor project
    There is a really good [[https://circleci.com/docs/2.0/getting-started/][getting started guide]] on the CircleCI website.

    Adding a project and CircleCI detects the programming language and your operating system.

    [[/images/circleci-add-project-detection.png]]

    Added the sample ~config.yml~ to the project as ~.configci/config.yml~.  The only change made to the config file was to update the version of Leiningen to 2.8.1 (was version 2.7.1).  Once this was added to the project and pushed up to the github repostitory, then we are ready to create a build.

    This launches the project on CircleCI and webhooks listen for new commits to the Github repository.

    Adding a [[https://circleci.com/gh/jr0cket/webapp-status-monitor/edit#badges][status badge]] to the Github readme was very simple too.  CircleCI provides the Markdown to add to the README.md page.

*** Testing status-monitor
    The Compojure template comes with a few tests that nicely show how to group tests and give some hints on things to test.

    Started adding tests to check the output generated by the visual components I am developing to represent the elements of the dashboard.

*** Coaching
    I created a Slack community specifically for the coaching, so we can keep our discussions around for several months if required.  We discussed what was to be achieved (at least initially) from the coaching, tooling and development experiences.


------------------------------------------

* 20180921 - Day 7: Clojure advocacy and Spacemacs
** Thoughts for today
   This morning I had a great conversation with an exciting company that is looking to move to Clojure for key computational parts of their systems.  Lots of discussion centred around finding and hiring Clojure developers, for which there are many options.

   The rest of the day was spent working on my book [Spacemacs for Clojure development](https://github.com/practicalli/spacemacs-gitbook/).

** Code from today
*** Content and elisp code snippets for my Spacemacs book:
    https://github.com/practicalli/spacemacs-gitbook/

** Activities in detail
   I have been steadily creating content for my book to help developers make the most out of Spacemacs for Clojure development.  There is still much content to go, however, there is lots of really useful things I have learnt and added over the last few weeks.

   I have also been adding more content ideas in the [[https://github.com/practicalli/spacemacs-gitbook/projects/1][Github project for the book]].

------------------------------------------

* 20180920 - Day 6: ClojureBridge London
** Thoughts for today
   Preparing for the ClojureBridge London event next weekend by reviewing the workshop content and enhancing some of the challenges and sample answers.

   Also carried out some user research for developer portals of several financial institues.  There was definately a large difference in usability and developer experience between the sites reviewed.  Hopefully my comments are of some contructive use and I wasnt overly critical.

** Code from today
*** Code examples and content for the ClojureBridge London workshop
    https://github.com/ClojureBridgeLondon/workshop-content-gitbook

** Activities in detail
   Improved several sections of the ClojureBridge workshop content.

------------------------------------------

* 20180919 - Day 5: A very Googley day - Alexa, Android and Googling answers
** Thoughts for today
   I was at an Amazon for an Alexa workshop building what they refer to as _skills_, their word for defining the things that you can configure Alexa to do.  It was good fun, very well explained and I also won an Echo dot (which should arrive in the post tomorrow).

   This evening I coached at [[https://codebar.io][Codebar]], helping a very bright person with their Augmented Reality application for Android which was written in Kotlin.  I can see why experienced Android developers are able to get a great rate for their work, as it feels like a lot of moving parts to build such a native app.  They managed to get further with the app and we even got some UI tests instrumented.

   Not progress on the Clojure app today, although had a very interesting talk about the need to do more to highlight what makes Clojure so special.  I did do some work on this for ClojureBridge London workshop https://clojurebridgelondon.github.io/workshop/introducing-clojure/

** Code from today
*** AWS Lambda function for several Alexa skills:
    https://github.com/jr0cket/aws-lambda-jenkins-deployer-alexa/commit/5e601b817c812549104d1a8f14ce7ade23c6c5f9

** Activities in detail
*** Alexa Workshop
    To make voice work, the service needs to understand millions of words so that it can accurately interpret what you are saying and have a better chance of doing the right thing.  If Alexa doesunt understand the words you say, then its not going to do what you want.

    The Alexa Framework can be used to enable any device, not just the devices from Amazon.

    They are called skills (rather than voice apps) as we are teaching Alexa to do something specific.


------------------------------------------

* 20180918 - Day 4: Are you mocking me :)
  Today was a great meetup at Signal Media.  Talked about the #100daysofcode challenge I am doing and the experiments with Scalable Vector Graphics. Discussed the case for ClojureScript and Reagent over JavaScript and React.js

  Also helped someone on Clojurians Slack write a keybinding for [lispy]() functions ~lispy-pair~ and ~lispy-quote~ that did not have keybindings defined in the package.  Lispy is an alternative to Evil and Smartparents and whilst interesting, its not something I am inclined to try myself.

** Thoughts for today
   There are so many companies using Clojure I keep finding out about.  The TV company Vue.tv uses Clojure for all their data processing around their broadcasting business.

   GraphQL in a lambda works surprisingly well according to Alex's talk.  That was really interesting.

** Code from today
*** Status monitor and Scalable Vector graphics
    https://github.com/jr0cket/webapp-status-monitor/commit/1c282057c2d1a7433a36ad50b2845c79e788f128

** Activities in detail
*** Mock data generators
     I'd like to test out the SVG dashboard with a number of different data sets.  Rather than just type a lot of random numbers into the code, I wrote a mock-data generator function.  This mock data first returned float values.

#+BEGIN_SRC clojure
(defn mock-data
  "Mock data generator"
  [maximum-value]
  (rand (+ maximum-value 1)))
#+END_SRC

    The ~mock-data~ function was refactored to generate either float or integer random data based on the type passed to the ~mock-data~ function as an argument.

    As the float generated number has multiple decimal places and we only want two for the display, the ~format~ function is used to limit the precision of the returning number to 2 decimal places.

#+BEGIN_SRC clojure
(defn mock-data
  "Mock data generator"
  [maximum-value]
  (if (float? maximum-value)
    (format "%.2f" (rand (+ maximum-value 1)))
    (rand-int (+ maximum-value 1))))
#+END_SRC

*** Joker linter
     As I was experimenting with a mock-data generator in the REPL experiments section, I noticed that Joker reports out of order issues.  So it will highlight if you try to call a function before its defined in the file.  This happens even if the function has already been evaluated in the repl.  This situation does remind me that Joker reads the whole Clojure file each time a change is made.

     I am finding Joker invaluable to guard against very silly mistakes and thus avoiding hunting through code for silly mistakes.

     More Joker awesomenessness.

------------------------------------------

* 20180917 - Day 3: Joker Clojure linter and SVG status bars
** Thoughts for today
   I had a little excursion into [[https://github.com/candid82/joker][Joker]], a linter for Clojure.  Someone was having problems getting the [[https://github.com/n2o/clojure-lint-spacemacs-layer][clojure-lint]] layer to work in Spacemacs, so I though I would give it a try and see if I could help.  I really like the feedback I get from the Joker linter, its very clearly presented and is very fast.

   I like coding interfaces with Scalable Vector Graphics (SVG) as the graphics are defined as data structures (when using the hiccup syntax).  So SVG is really easy to use with Clojure.  It requires a little trial and error as its not specifically documented as far as I can tell, but having a repl means is really quick to experiment.

** Code from today
*** Defined a status bar component using Hiccup syntax to generate SVG
    https://github.com/jr0cket/webapp-status-monitor/commit/4d7925184c8cf181f0addfb8fb829844ba56002d
    https://github.com/jr0cket/webapp-status-monitor/commit/17efddc7233fb134b107c89f88fe3875ff40f83c

** Activities in detail
*** Continuing the status-monitor webapp
    I added some mock status bars to my status-monitor application, using hiccup and [Scalable Vector Graphics (SVG)](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) to add some colour and design to the page.

    There is a bit of a challenge with using SVG with the Hiccup syntax, as it does not seem to be documented anywhere.  However, its not that hard to work out by looking at the [SVG elements in HTML](https://developer.mozilla.org/en-US/docs/Web/SVG/Element).  We are generating HTML after all.

    I did find some SVG projects that may be interesting to try:
    > [[https://github.com/pallix/tikkba][Tikkba]] for the creation and the dynamic modification of SVG documents
    > [[http://liebke.github.io/analemma/][analemma]] for generating charts and Scalable Vector Graphics (SVG)
    > [[https://github.com/stathissideris/dali][dali]] for representing the SVG graphics format. It allows the creation and manipulation of SVG files. The syntax used to describe the graphical elements is based on hiccup with a few extensions
    > [[https://github.com/gfredericks/svg-wrangler][svg-wrangler]] a collection of Clojure functions to help assemble SVG images via hiccup data structures

*** Joker linter and clojure-lint layer in Spacemacs
    I setup on [[https://github.com/candid82/joker][Joker]] on ubuntu by downloading a [[https://github.com/candid82/joker/releases][pre-compiled linux binary]] and placing it in ~~/bin~ which is already on my executable path.

    Added the ~clojure-lint~ layer to ~.spacemacs~ configuration file and restarted Spacemacs with ~SPC q r~.

    Opened my status-monitor ~status-monitor.handler~ namespace and it showed me where I had been less clear with my code straight away.

    If I call a function with the wrong number of argument then Joker will put an orange dot in the margin.  That's so awesome.

    I will refactor a few things that Joker found tomorrow, such especially refining the namespace refer.

------------------------------------------

* 20180916 - Day 2: Investigating compojure-template and lein-ring
  Today was more a journey of discovery on how projects from the compojure-template can be run and how the lein-ring plugin works.

** Thoughts for today
   I really appreciated the work done by all Open Source project owners and maintainers, especially @weavejester who has created so many great projects for Clojure.

   I didnt write a lot of code today, but felt I learnt some really invaluable information.  It also feels good to give back to an open source project, no matter how big or small the contribution.

   Not having to concern myself with a delivery date for my project allowed me the feedom to dive into the projects and tools I have been using for quite a while.  This has given me a much better understanding of how to get the most out of them and help me teach other developers how to use them.  It is also way more fun.

** Code from today
   I submitted a [pull request](https://github.com/weavejester/compojure-template/pull/25) to update the each library dependency to their latest stable version in the compojure-template.


** Activities in detail
   Here is what I got up to in a lot more detail.

*** compojure-template pull request

    When creating a new project from the [compojure-template]() yesterday I noticed that the version of libraries used in the template were a little dated.  Those versions stil work, but I decided to create a pull request with the latest stable versions of those libraries.

    https://github.com/weavejester/compojure-template/pull/25

    There was an existing pull request to update the libraries dependencies, however, that was also out of date.

    The ~compojure-template~ project only describes how to run a generated project using the lein-ring plugin, using ~lein ring server~.  The [[https://github.com/weavejester/lein-ring][lein-ring]] project readme describes [[https://github.com/weavejester/lein-ring#executable-jar-files][how to run the project from the Java command line]], but there is no reference to this information on the [[https://github.com/weavejester/compojure-template/][compojure-template]] project.  Again, I spotted a [[https://github.com/weavejester/compojure-template/pull/23][pull request]] to add these details to the readme so I added a thumbs up reaction with hope the maintainer will accept the pull request.

*** Digging deeper into lein-ring plugin
     It is common in Clojure projects to define a ~-main~ function that is the start point to running the application.  However, the compojure-template doesnt generate a project with a ~-main~ function, instead it defines a Var called ~app~ that is the start of our application.

     The reason for this approach is so that the compojure application can be packaged into a Java Web Archive (WAR) file and dropped into an existing Java Application Server (Tomcat, Jett, etc.).  This is the traditional approach to deploying a JVM webapp.

     The lein-ring plugin adds a task called ~ring~ to Leiningen, so you can start the application on the command line using

#+BEGIN_SRC shell
lein ring server
#+END_SRC

     Running the compojure project using lein-ring plugin starts an embedded Jetty web application server and passes the ~app~ to that running process to start listening for http requests.

*** Running as a stand alone application
     With the rise in Cloud computing it is more common to run each application in its own embedded server, rather than deploying mulitple apps on a single applicaton server.  This new approach enables vertical scaling and parallel processing, something Clojure is an excellent language for.

     Rather than write our own ~-main~ function to call Jetty, we can ask lein-ring plugin to do it for us.  A ~-main~ function is boilerplate code after all.

     Use the lein-ring version of ~lein uberjar~ to generate a JAR file

#+BEGIN_SRC shell
lein ring uberjar
#+END_SRC

     Taking a look at the contents of the generated JAR file we can see the additions made by the plugin.

     > I use Spacemacs to open the Jar file as it will list all the files and let me read each text file it contains.

     An application entry point has been added to the ~meta-inf/manifest.mf~ by specifying ~Main-Class: status_monitor.handler.main~

     Hold on though... we didnt have a ~main~ namespace in our code, so how does that work?

     Well, lein-ring had created a file for that namespace with a ~-main~ function within it.  Here is the code contained within this automatically generated namespace.

#+BEGIN_SRC clojure
(do
  (clojure.core/ns status-monitor.handler.main
    (:gen-class))

  (clojure.core/defn -main []
    ((do
       (clojure.core/require (quote ring.server.leiningen))

       (clojure.core/resolve (quote ring.server.leiningen/serve)))
     (quote {:ring
             {:handler status-monitor.handler/app,
              :open-browser? false,
              :stacktraces? false,
              :auto-reload? false,
              :auto-refresh? false}}))))
#+END_SRC

     The code requires the namespace ~ring.server.leiningen~ so ic can run the ~serve~ function that takes the ~app~ as an argument.  ~serve~ will run an embedded jetty server and run our ~app~ within.

     As ~uberjar~ is typically used to deply your application to a remote server (e.g. uat, production), then development features are set to false.  We dont really want a browser window to be opened when we run the app on a production server.

------------------------------------------

* 20180915 - Day 1: Staus Monitor mock website (server side) -
  Started a simple status monitor application to collate monitoring information from different sources into one simple web dashboard.

** Thoughts from today
   The compojure template is easy to get started with, it just works with the help of the ~lein-ring~ plugin.  The plugin takes the app defined in the ~src/status_monitor/handler.clj~ file and passes it to an embedded Jetty application server.  The plugin abstracts this detail away, making the project easy to run and less code to write.

   This abstraction does make it a little harder to understand how this application actually runs and there is a lack of information on the template website.

** Code from today
   https://github.com/jr0cket/webapp-status-monitor

** Details of today's activities
*** New compojure project and dependency version updates
    Started a new project using the Leiningen [compojure-template](https://github.com/weavejester/compojure-template)

#+BEGIN_SRC shell
lein new compojure status-monitor
#+END_SRC

    This created a project using the ~ring~ and ~compojure~ libraries and Clojure 1.8.0

#+BEGIN_SRC clojure
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [compojure "1.5.1"]
                 [ring/ring-defaults "0.2.1"]]
#+END_SRC

    The project was updated to use the creative commons licence, rather than the deffault Eclipse public license which has is more restrictive.

    Version 1.9.0 is now the current stable version of Clojure, so that has been updated in the dependencies.

    The lein-compojure template is very simple to get started with, although it seems the libraries are a little behind the latest.  The project runs successfully without upgrading versions.  It is usually better to use the latest stable versions of these libraries to pick up any fixes.

    The latest stable versions were found via https://clojars.org/.

    > Consider submitting a pull request to update the lein-compojure template project on Github.

*** Running the REPL from Spacemacs

    Although the project runs well from the command line using the ~lein-ring~ plugin, we dont get the full benefit of the REPL until we connect our editor to the REPL.  With the Compojure template you need to run the repl from Spacemacs as there is no way to connect to the REPL port from Spacemacs when the project is run with ~lein ring server~.

    Using the keybinding ~, '~ is a quick way to start the repl in Spacemacs.

*** Enhancing the webpage
    The website is a litle basic in terms of output, so I added Bootstrap CSS and JavaScript libraries to the project as a simple way to make the output look a little more professional.

    To use Bootstrap easily and avoid writing lots of html code, I used the Hiccup library.  Hiccup allows you to generate html code from Clojure vectors that contain Clojure keywords representing html tags.  Generating an html ~h1~ header and its text is written as ~[:h1 "I am an HTML header"]~.

    Using Clojure syntax in this way, makes it much easier to type.  Using this syntax also makes it easy to use structured editing with your code.

    The project needs to include Hiccup library as a dependency.  Using the ~clj-refactor~ tools in Emacs, I added the hiccup dependencies and also hotloaded it into the already running repl.

*** Added Hiccup and Bootstrap to create a better web page
    Created the basics of our monitor dashboard page without writing html direct.

    Added the Hiccup library to generate html from Clojure data structures and
keywords.

    Using the hiccup.page/html5 function we created a page that allows us to include
the Bootstrap CSS and JavaScript libraries.  Hiccup allows us to include CSS
styles in the data structures, or more usefully refer to the Bootstrap styles by
name.

------------------------------------------

* 20180914 - Day 0: 14th September, 2016
  Test out my development environment is working.  For the exercises I will be using Spacemacs, a community configuration for Emacs that also provides a comprehensive set of Vim states (Evil mode) that make editing code more effective.

  Spacemacs is configured to use the Clojure layer, which pulls in CIDER packages, providing a comprehensive Clojure development environment that is equivalent to the features of an IDE without the resource requirements.

  I will use Spacemacs for all coding and documentation for this 100 days challenge.  Along the way I will document my usage of Spacemacs and useful practices in the online guide: [Practicalli Spacemacs](https://practicalli.github.io/spacemacs).

** Today's Progress
   As today is just a check of my environment, then no progress to report yet.

** Thoughts
   I am a little nervous about this challenge as it will demonstrate just how much coding skill I currently have. My imposter syndome is kicking in a little as I think about it.  However, the excitement of emersing myself in Clojure coding for 100 days is over-riding this nervousness and hopefully this will continue to the end of the challenge.

** Link to work
   [[https://practicalli.github.io/spacemacs][Practicalli Spacemacs]]
   [[https://github.com/jr0cket/100-days-of-clojure-code][My Github repository for 100 Days Of Clojure Code]]
